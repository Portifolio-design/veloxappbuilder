<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>VeloxAppBuilder</title>
<style>
  body { font-family: Inter, Arial, Helvetica, sans-serif; margin:0; padding:16px; background:#f6f7fb; color:#111; }
  .card { background:#fff; border-radius:10px; box-shadow:0 6px 18px rgba(20,20,50,0.06); padding:16px; margin-bottom:16px;}
  header{display:flex;align-items:center;gap:12px}
  header h1{margin:0;font-size:20px}
  label{display:block;margin-top:8px;font-weight:600;font-size:13px}
  input[type=text], input[type=password], textarea, select { width:100%; padding:8px; margin-top:6px; border:1px solid #ddd; border-radius:6px; box-sizing:border-box;}
  button{padding:8px 12px;border-radius:8px;border:0;background:#1f7aed;color:#fff;cursor:pointer;margin-top:8px}
  button.secondary{background:#6b7280}
  pre{background:#f4f6fb;padding:8px;border-radius:6px;overflow:auto}
  .row{display:flex;gap:8px}
  .col{flex:1}
  .small{font-size:12px;color:#555}
  .danger{background:#ef4444}
  .success{background:#10b981}
  footer{font-size:12px;color:#666;margin-top:12px}
  .dev-area{background:#fffbe6;border:1px solid #ffe4a3;padding:12px;border-radius:8px}
</style>
</head>
<body>
<header class="card">
  <img src="" alt="" id="appIcon" style="width:48px;height:48px;border-radius:10px;background:#ddd"/>
  <div>
    <h1>VeloxAppBuilder</h1>
    <div class="small">Crie, exporte e emita licenças (trial 10 dias / full vitalícia)</div>
  </div>
</header>

<section class="card">
  <h3>Login & Licença</h3>
  <div id="loginSection">
    <div class="row">
      <div class="col">
        <label>Login com Conta Google (simulado)</label>
        <input type="text" id="googleEmail" placeholder="Digite seu e-mail Google" />
      </div>
      <div style="width:150px">
        <label>&nbsp;</label>
        <button id="btnGoogleLogin">Conectar</button>
      </div>
    </div>

    <label>Chave de licença (cole aqui)</label>
    <input type="text" id="licenseInput" placeholder="Cole o token JWT (trial ou full)" />
    <div class="row">
      <button id="btnValidate">Validar Licença</button>
      <button id="btnRequest" class="secondary">Solicitar chave por e‑mail</button>
    </div>
    <div id="licenseStatus" class="small" style="margin-top:8px"></div>
  </div>
</section>

<section class="card">
  <h3>Construtor de App (Exporta ZIP)</h3>
  <label>Nome do app</label>
  <input type="text" id="appName" value="MeuApp Velox" />
  <label>Descrição</label>
  <textarea id="appDesc" rows="3">App criado com VeloxAppBuilder</textarea>
  <label>Ícone (PNG)</label>
  <input type="file" id="appIconFile" accept="image/*" />
  <div class="row">
    <button id="btnExport">Exportar ZIP (projeto PWA)</button>
    <button id="btnPreview" class="secondary">Visualizar index.html gerado</button>
  </div>
  <div class="small">O ZIP contém um PWA mínimo + app.js com validação de licença offline.</div>
</section>

<section class="card">
  <h3>Área do Desenvolvedor (Protegida)</h3>
  <div id="devLoginBox">
    <label>Senha do desenvolvedor</label>
    <input type="password" id="devPass" placeholder="Senha de acesso" />
    <div class="row">
      <button id="btnDevLogin">Entrar como Desenvolvedor</button>
    </div>
    <div class="small">Senha padrão: <strong>VeloxMaster2025</strong></div>
  </div>

  <div id="devArea" style="display:none;margin-top:12px" class="dev-area">
    <h4>Painel de chaves (JWT)</h4>
    <div class="small">Gere um par de chaves RSA (privada -> você guarda; pública -> embute no app gerado).</div>
    <div class="row">
      <button id="btnGenKey">Gerar par de chaves RSA (2048)</button>
      <button id="btnImportKey" class="secondary">Importar private PEM</button>
      <button id="btnClearKeys" class="secondary danger">Limpar chaves</button>
    </div>

    <label>Chave pública (PEM) — distribua apenas a pública para apps</label>
    <pre id="publicPem" style="height:120px;overflow:auto"></pre>
    <div class="row">
      <button id="btnCopyPub">Copiar pública</button>
      <button id="btnDownloadPub" class="secondary">Baixar pública</button>
    </div>

    <label>Chave privada (PEM) — guarde em local seguro</label>
    <pre id="privatePem" style="height:120px;overflow:auto"></pre>
    <div class="row">
      <button id="btnCopyPriv">Copiar privada</button>
      <button id="btnDownloadPriv" class="secondary">Baixar privada</button>
    </div>

    <hr/>
    <h4>Emitir Licença</h4>
    <label>Tipo de licença</label>
    <select id="licenseType">
      <option value="trial">Trial (10 dias)</option>
      <option value="full">Full (vitalícia)</option>
    </select>
    <label>Para o e-mail do comprador (opcional)</label>
    <input type="text" id="licenseOwnerEmail" placeholder="email@exemplo.com" />
    <div class="row">
      <button id="btnIssue">Gerar licença (JWT)</button>
      <button id="btnCopyToken" class="secondary">Copiar token</button>
    </div>
    <label>Token gerado</label>
    <pre id="issuedToken" style="height:80px;overflow:auto"></pre>
    <div class="small">Envie o token ao comprador. No app, cole o token no campo de licença.</div>
  </div>
</section>

<footer class="card">
  <div class="small">Ao solicitar chave via e‑mail será aberto um rascunho para: <strong>portifoliodesigngrafico@gmail.com</strong></div>
</footer>

<!-- JS libraries -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.0/dist/jszip.min.js"></script>

<script>
/* Utilities: base64url, PEM conversions, JWT signing with SubtleCrypto */
function toBase64Url(buf) {
  const b64 = btoa(String.fromCharCode.apply(null, new Uint8Array(buf)));
  return b64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');
}
function encodeObj(obj){ return toBase64Url(new TextEncoder().encode(JSON.stringify(obj))); }
function arrayBufferToPem(buffer, type) {
  const b64 = toBase64Url(buffer).replace(/-/g,'+').replace(/_/g,'/');
  // create standard base64 with padding
  let bin = atob(b64);
  let raw = '';
  for (let i=0;i<bin.length;i++) raw += String.fromCharCode(bin.charCodeAt(i));
  // re-encode to standard base64 with padding
  const stdB64 = btoa(raw);
  const pem = '-----BEGIN ' + type + '-----\\n' + stdB64.match(/.{1,64}/g).join('\\n') + '\\n-----END ' + type + '-----\\n';
  return pem;
}
function b64ToArrayBuffer(b64) {
  const bin = atob(b64);
  const len = bin.length;
  const bytes = new Uint8Array(len);
  for (let i=0;i<len;i++) bytes[i]=bin.charCodeAt(i);
  return bytes.buffer;
}
function pemToArrayBuffer(pem){
  const lines = pem.split('\\n');
  const base64 = lines.slice(1, lines.length-2).join('');
  return b64ToArrayBuffer(base64);
}
function downloadFile(filename, content){ 
  const a=document.createElement('a');
  const blob=new Blob([content], {type:'text/plain'});
  a.href=URL.createObjectURL(blob); a.download=filename; a.click();
}

/* Globals for keys */
let privateKeyObj = null;
let publicKeyObj = null;
let privatePemStored = localStorage.getItem('velox_private_pem') || '';
let publicPemStored = localStorage.getItem('velox_public_pem') || '';
if(privatePemStored) document.getElementById('privatePem').textContent = privatePemStored;
if(publicPemStored) document.getElementById('publicPem').textContent = publicPemStored;

/* Google login (simulado) */
document.getElementById('btnGoogleLogin').addEventListener('click', ()=>{
  const email = document.getElementById('googleEmail').value.trim();
  if(!email || !email.includes('@')) return alert('Informe um e-mail válido');
  alert('Simulação de login: ' + email);
});

/* Mailto request for license */
document.getElementById('btnRequest').addEventListener('click', ()=>{
  const appName = document.getElementById('appName').value || 'MeuApp Velox';
  const mailto = 'mailto:portifoliodesigngrafico@gmail.com'
    + '?subject=' + encodeURIComponent('Solicitação de chave de licença: ' + appName)
    + '&body=' + encodeURIComponent('Olá,%0A%0AGostaria de solicitar uma chave de licença para o aplicativo: ' + appName + '%0A%0AEmail do comprador:%0A%0AObrigado.');
  window.location.href = mailto;
});

/* Validate license by decoding payload and checking exp (trial) */
document.getElementById('btnValidate').addEventListener('click', ()=>{
  const token = document.getElementById('licenseInput').value.trim();
  if(!token) return alert('Cole o token de licença');
  try{
    const parts = token.split('.');
    if(parts.length !== 3) throw new Error('Token JWT inválido');
    const payload = JSON.parse(atob(parts[1]));
    const now = Math.floor(Date.now()/1000);
    if(payload.type === 'trial'){
      if(payload.exp && payload.exp > now) {
        document.getElementById('licenseStatus').textContent = 'Licença TRIAL ativa até ' + new Date(payload.exp*1000).toLocaleString();
      } else {
        document.getElementById('licenseStatus').textContent = 'Licença TRIAL expirada.';
      }
    } else if(payload.type === 'full'){
      document.getElementById('licenseStatus').textContent = 'Licença FULL validada (vitalícia).';
    } else {
      document.getElementById('licenseStatus').textContent = 'Licença inválida: tipo desconhecido.';
    }
  }catch(e){
    document.getElementById('licenseStatus').textContent = 'Erro ao validar licença: ' + e.message;
  }
});

/* Developer login */
document.getElementById('btnDevLogin').addEventListener('click', ()=>{
  const pass = document.getElementById('devPass').value;
  if(pass === 'VeloxMaster2025'){
    document.getElementById('devArea').style.display = 'block';
    document.getElementById('devLoginBox').style.display = 'none';
  } else {
    alert('Senha incorreta');
  }
});

/* Generate RSA keypair */
document.getElementById('btnGenKey').addEventListener('click', async ()=>{
  if(!confirm('Gerar novo par de chaves RSA 2048? A privada ficará disponível apenas localmente neste navegador.')) return;
  const keyPair = await window.crypto.subtle.generateKey(
    {name:'RSASSA-PKCS1-v1_5', modulusLength:2048, publicExponent:new Uint8Array([1,0,1]), hash:'SHA-256'},
    true,
    ['sign','verify']
  );
  privateKeyObj = keyPair.privateKey;
  publicKeyObj = keyPair.publicKey;
  const spki = await window.crypto.subtle.exportKey('spki', publicKeyObj);
  const pkcs8 = await window.crypto.subtle.exportKey('pkcs8', privateKeyObj);
  const publicPem = arrayBufferToPem(spki, 'PUBLIC KEY');
  const privatePem = arrayBufferToPem(pkcs8, 'PRIVATE KEY');
  document.getElementById('publicPem').textContent = publicPem;
  document.getElementById('privatePem').textContent = privatePem;
  localStorage.setItem('velox_public_pem', publicPem);
  localStorage.setItem('velox_private_pem', privatePem);
  alert('Par de chaves gerado e salvo localmente (localStorage). Guarde a privada em local seguro.');
});

/* Import private PEM */
document.getElementById('btnImportKey').addEventListener('click', async ()=>{
  const pem = prompt('Cole a chave privada PEM (PKCS8) aqui:');
  if(!pem) return;
  try{
    const keyBuffer = pemToArrayBuffer(pem);
    const imported = await window.crypto.subtle.importKey('pkcs8', keyBuffer,
      {name:'RSASSA-PKCS1-v1_5', hash:'SHA-256'}, true, ['sign']);
    privateKeyObj = imported;
    document.getElementById('privatePem').textContent = pem;
    localStorage.setItem('velox_private_pem', pem);
    alert('Chave privada importada com sucesso.');
  }catch(e){ alert('Erro ao importar chave: ' + e.message); }
});

/* Clear keys */
document.getElementById('btnClearKeys').addEventListener('click', ()=>{
  if(!confirm('Remover chaves do localStorage? (A private key será removida localmente)')) return;
  localStorage.removeItem('velox_private_pem');
  localStorage.removeItem('velox_public_pem');
  document.getElementById('privatePem').textContent = '';
  document.getElementById('publicPem').textContent = '';
  privateKeyObj = null; publicKeyObj = null;
  alert('Chaves removidas.');
});

/* Copy / Download buttons */
document.getElementById('btnCopyPub').addEventListener('click', ()=>navigator.clipboard.writeText(document.getElementById('publicPem').textContent));
document.getElementById('btnCopyPriv').addEventListener('click', ()=>navigator.clipboard.writeText(document.getElementById('privatePem').textContent));
document.getElementById('btnDownloadPub').addEventListener('click', ()=>downloadFile('velox_public.pem', document.getElementById('publicPem').textContent));
document.getElementById('btnDownloadPriv').addEventListener('click', ()=>downloadFile('velox_private.pem', document.getElementById('privatePem').textContent));

/* Issue JWT using privateKeyObj (RSASSA-PKCS1-v1_5 SHA-256) */
async function signJwt(payloadObj){
  if(!privateKeyObj){
    // try to import from localStorage
    const pem = localStorage.getItem('velox_private_pem');
    if(pem){
      try {
        const buf = pemToArrayBuffer(pem);
        privateKeyObj = await window.crypto.subtle.importKey('pkcs8', buf, {name:'RSASSA-PKCS1-v1_5', hash:'SHA-256'}, true, ['sign']);
      } catch(e){
        throw new Error('Não há chave privada disponível para assinar. Importe ou gere uma no painel do desenvolvedor.');
      }
    } else {
      throw new Error('Não há chave privada disponível para assinar. Importe ou gere uma no painel do desenvolvedor.');
    }
  }
  const header = { alg: 'RS256', typ: 'JWT' };
  const iat = Math.floor(Date.now()/1000);
  payloadObj.iat = iat;
  const encoded = encodeObj(header) + '.' + encodeObj(payloadObj);
  const enc = new TextEncoder().encode(encoded);
  const sig = await window.crypto.subtle.sign({name:'RSASSA-PKCS1-v1_5'}, privateKeyObj, enc);
  const token = encoded + '.' + toBase64Url(sig);
  return token;
}

document.getElementById('btnIssue').addEventListener('click', async ()=>{
  const type = document.getElementById('licenseType').value;
  const owner = document.getElementById('licenseOwnerEmail').value.trim() || null;
  try{
    const payload = { type: type };
    if(owner) payload.owner = owner;
    if(type === 'trial'){
      const now = Math.floor(Date.now()/1000);
      const tenDays = 10*24*60*60;
      payload.exp = now + tenDays;
    }
    const token = await signJwt(payload);
    document.getElementById('issuedToken').textContent = token;
    await navigator.clipboard.writeText(token);
    alert('Token gerado e copiado para a área de transferência.');
  }catch(e){
    alert('Erro ao gerar token: ' + e.message);
  }
});

document.getElementById('btnCopyToken').addEventListener('click', ()=>navigator.clipboard.writeText(document.getElementById('issuedToken').textContent));

/* Export ZIP (PWA minimal + app.js with license validation using public key from dev) */
document.getElementById('btnExport').addEventListener('click', async ()=>{
  const name = document.getElementById('appName').value || 'MeuApp Velox';
  const desc = document.getElementById('appDesc').value || '';
  const iconFile = document.getElementById('appIconFile').files[0];
  let iconDataUrl = '';
  if(iconFile){
    iconDataUrl = await new Promise(res=>{
      const r=new FileReader(); r.onload=()=>res(r.result); r.readAsDataURL(iconFile);
    });
  }
  const publicPem = document.getElementById('publicPem').textContent || localStorage.getItem('velox_public_pem') || '';
  if(!publicPem) if(!confirm('Nenhuma chave pública encontrada. Deseja continuar sem embutir uma chave pública? (Recomenda-se embutir a pública para validação offline)')) return;

  const zip = new JSZip();
  // index.html for exported app
  const appIndex = `<!doctype html>
  <html>
  <head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><title>${escapeHtml(name)}</title></head>
  <body style="font-family:Arial,Helvetica,sans-serif;padding:20px">
    <h1>${escapeHtml(name)}</h1>
    <p>${escapeHtml(desc)}</p>
    ${iconDataUrl?'<img src="'+iconDataUrl+'" width="120" alt="icon"/>':''}
    <div>
      <input id="license" placeholder="Cole sua chave de licença (JWT)" style="width:100%;padding:8px;margin-top:8px"/>
      <div style="margin-top:8px">
        <button onclick="validate()">Validar licença</button>
        <div id="status" style="margin-top:8px;color:#333"></div>
      </div>
    </div>
    <script>
      // license validator using public PEM embedded
      const publicPem = ${publicPem?JSON.stringify(publicPem):'null'};
      function pemToArrayBuffer(pem){
        const lines = pem.split('\\n'); const base64 = lines.slice(1, lines.length-2).join(''); return Uint8Array.from(atob(base64), c=>c.charCodeAt(0)).buffer;
      }
      async function importPub(pem){
        if(!pem) return null;
        const spki = pemToArrayBuffer(pem);
        return await crypto.subtle.importKey('spki', spki, {name:'RSASSA-PKCS1-v1_5', hash:'SHA-256'}, true, ['verify']);
      }
      async function verifyJwt(token){
        try{
          const parts = token.split('.'); if(parts.length!==3) throw 'JWT inválido';
          const header = JSON.parse(atob(parts[0])); const payload = JSON.parse(atob(parts[1])); const sig = parts[2];
          const enc = new TextEncoder().encode(parts[0]+'.'+parts[1]);
          const sigArr = (function(){ let s = sig.replace(/-/g,'+').replace(/_/g,'/'); while(s.length%4) s+='='; return Uint8Array.from(atob(s), c=>c.charCodeAt(0)); })();
          const pub = await importPub(publicPem);
          if(!pub) throw 'Chave pública não embutida';
          const ok = await crypto.subtle.verify('RSASSA-PKCS1-v1_5', pub, sigArr, enc);
          if(!ok) throw 'Assinatura inválida';
          const now = Math.floor(Date.now()/1000);
          if(payload.type==='trial'){
            if(payload.exp && payload.exp>now) return {status:'trial', payload};
            else return {status:'expired', payload};
          } else if(payload.type==='full') return {status:'full', payload};
          else return {status:'invalid', payload};
        }catch(e){ return {status:'error', message: String(e)}; }
      }
      async function validate(){
        const token=document.getElementById('license').value.trim(); if(!token){alert('Cole o token');return;}
        const r=await verifyJwt(token);
        const s=document.getElementById('status');
        if(r.status==='trial') s.textContent='TRIAL ativa até '+new Date(r.payload.exp*1000).toLocaleString();
        else if(r.status==='full') s.textContent='FULL validada (vitalícia)';
        else if(r.status==='expired') s.textContent='TRIAL expirada';
        else s.textContent='Erro: '+(r.message||r.status);
      }
    </script>
  </body>
  </html>`;

  zip.file('index.html', appIndex);
  zip.file('manifest.webmanifest', JSON.stringify({name, short_name:name.slice(0,12), start_url:'/', display:'standalone', description:desc}, null, 2));
  zip.file('app.js', '// App logic minimal (license validator inside index.html)');

  if(iconDataUrl){
    // convert dataURL to blob binary for zip
    const base64 = iconDataUrl.split(',')[1];
    zip.file('icon.png', base64, {base64: true});
  }
  if(publicPem) zip.file('public.pem', publicPem);

  const blob = await zip.generateAsync({type:'blob'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=(name.replace(/\s+/g,'_')||'app')+'-velox-export.zip'; a.click();
});

/* Preview generated index.html */
document.getElementById('btnPreview').addEventListener('click', async ()=>{
  const name = document.getElementById('appName').value || 'MeuApp Velox';
  const desc = document.getElementById('appDesc').value || '';
  const publicPem = document.getElementById('publicPem').textContent || '';
  const preview = `<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>${escapeHtml(name)}</title></head><body><h1>${escapeHtml(name)}</h1><p>${escapeHtml(desc)}</p><p>Chave pública embutida: ${publicPem? 'Sim':'Não'}</p></body></html>`;
  const w = window.open('about:blank','_blank'); w.document.write(preview); w.document.close();
});

/* Helpers */
function escapeHtml(s){ return (s||'').toString().replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

</script>
</body>
</html>
